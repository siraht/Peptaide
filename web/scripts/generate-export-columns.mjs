import fs from 'node:fs/promises'
import path from 'node:path'

function findLineIndex(lines, startIndex, predicate) {
  for (let i = startIndex; i < lines.length; i++) {
    if (predicate(lines[i])) return i
  }
  return -1
}

function indentOf(line) {
  const m = line.match(/^(\s*)/)
  return m ? m[1].length : 0
}

function escapeTsString(s) {
  return s.replaceAll('\\', '\\\\').replaceAll("'", "\\'")
}

function extractPublicTableNames(lines) {
  const publicIdx = findLineIndex(lines, 0, (l) => /^\s*public:\s*{\s*$/.test(l))
  if (publicIdx === -1) {
    throw new Error('Could not find "public: {" block in database.types.ts')
  }

  const tablesIdx = findLineIndex(lines, publicIdx + 1, (l) => /^\s*Tables:\s*{\s*$/.test(l))
  if (tablesIdx === -1) {
    throw new Error('Could not find "Tables: {" block under public schema in database.types.ts')
  }

  const tablesIndent = indentOf(lines[tablesIdx])
  const tableNameIndent = tablesIndent + 2

  const tableNames = []
  for (let i = tablesIdx + 1; i < lines.length; i++) {
    const line = lines[i]
    if (new RegExp(`^\\s{${tablesIndent}}}\\s*$`).test(line)) {
      break
    }
    const m = line.match(new RegExp(`^\\s{${tableNameIndent}}([A-Za-z0-9_]+):\\s*{\\s*$`))
    if (m) tableNames.push(m[1])
  }

  if (tableNames.length === 0) {
    throw new Error('No table names found under public.Tables')
  }

  return tableNames
}

function extractRowColumnsForTable(lines, tableName) {
  const tableLineIdx = findLineIndex(lines, 0, (l) => new RegExp(`^\\s+${tableName}:\\s*{\\s*$`).test(l))
  if (tableLineIdx === -1) {
    throw new Error(`Could not find table block for ${tableName}`)
  }

  const rowIdx = findLineIndex(lines, tableLineIdx + 1, (l) => /^\s*Row:\s*{\s*$/.test(l))
  if (rowIdx === -1) {
    throw new Error(`Could not find Row block for ${tableName}`)
  }

  const rowIndent = indentOf(lines[rowIdx])
  const fieldIndent = rowIndent + 2
  const columns = []

  for (let i = rowIdx + 1; i < lines.length; i++) {
    const line = lines[i]
    if (new RegExp(`^\\s{${rowIndent}}}\\s*$`).test(line)) {
      break
    }
    const m = line.match(new RegExp(`^\\s{${fieldIndent}}([A-Za-z0-9_]+):\\s*`))
    if (m) columns.push(m[1])
  }

  if (columns.length === 0) {
    throw new Error(`No Row columns parsed for ${tableName}`)
  }

  return columns
}

function extractRowColumnTypeExprsForTable(lines, tableName) {
  const tableLineIdx = findLineIndex(lines, 0, (l) => new RegExp(`^\\s+${tableName}:\\s*{\\s*$`).test(l))
  if (tableLineIdx === -1) {
    throw new Error(`Could not find table block for ${tableName}`)
  }

  const rowIdx = findLineIndex(lines, tableLineIdx + 1, (l) => /^\s*Row:\s*{\s*$/.test(l))
  if (rowIdx === -1) {
    throw new Error(`Could not find Row block for ${tableName}`)
  }

  const rowIndent = indentOf(lines[rowIdx])
  const fieldIndent = rowIndent + 2
  const typeExprs = {}

  for (let i = rowIdx + 1; i < lines.length; i++) {
    const line = lines[i]
    if (new RegExp(`^\\s{${rowIndent}}}\\s*$`).test(line)) {
      break
    }
    const m = line.match(new RegExp(`^\\s{${fieldIndent}}([A-Za-z0-9_]+):\\s*(.+)$`))
    if (m) typeExprs[m[1]] = m[2].trim()
  }

  if (Object.keys(typeExprs).length === 0) {
    throw new Error(`No Row column types parsed for ${tableName}`)
  }

  return typeExprs
}

function inferColumnKind(tsTypeExpr) {
  const unionParts = tsTypeExpr
    .split('|')
    .map((p) => p.trim())
    .filter((p) => p !== 'null' && p !== 'undefined')

  if (unionParts.some((p) => p === 'Json' || p.endsWith('[]'))) return 'json'
  if (unionParts.some((p) => p === 'boolean')) return 'boolean'
  if (unionParts.some((p) => p === 'number')) return 'number'
  return 'string'
}

async function main() {
  const projectRoot = path.resolve(process.cwd())
  const typesPath = path.join(projectRoot, 'src', 'lib', 'supabase', 'database.types.ts')
  const outPath = path.join(projectRoot, 'src', 'lib', 'export', 'exportColumns.ts')
  const outKindsPath = path.join(projectRoot, 'src', 'lib', 'export', 'exportColumnKinds.ts')

  const content = await fs.readFile(typesPath, 'utf8')
  const lines = content.split(/\r?\n/)

  const tableNames = extractPublicTableNames(lines)
  tableNames.sort((a, b) => a.localeCompare(b))

  const entries = []
  const kindEntries = []
  for (const tableName of tableNames) {
    const cols = extractRowColumnsForTable(lines, tableName)
    const typeExprs = extractRowColumnTypeExprsForTable(lines, tableName)
    const colsLit = cols.map((c) => `'${escapeTsString(c)}'`).join(', ')
    entries.push(`  ${tableName}: [${colsLit}],`)

    const kindsLines = cols.map((c) => `    '${escapeTsString(c)}': '${inferColumnKind(typeExprs[c] ?? '')}',`)
    kindEntries.push(`  ${tableName}: {\n${kindsLines.join('\n')}\n  },`)
  }

  const out = [
    '// This file is auto-generated by `web/scripts/generate-export-columns.mjs`.',
    '// Do not edit by hand. Regenerate after DB type generation.',
    '',
    "import type { Database } from '@/lib/supabase/database.types'",
    '',
    "export type ExportTableName = keyof Database['public']['Tables']",
    '',
    "export const EXPORT_COLUMNS: Record<ExportTableName, readonly string[]> = {",
    ...entries,
    '}',
    '',
  ].join('\n')

  const outKinds = [
    '// This file is auto-generated by `web/scripts/generate-export-columns.mjs`.',
    '// Do not edit by hand. Regenerate after DB type generation.',
    '',
    "import type { ExportTableName } from './exportColumns'",
    '',
    "export type ExportColumnKind = 'string' | 'number' | 'boolean' | 'json'",
    '',
    'export const EXPORT_COLUMN_KINDS: Record<ExportTableName, Record<string, ExportColumnKind>> = {',
    ...kindEntries,
    '}',
    '',
  ].join('\n')

  await fs.mkdir(path.dirname(outPath), { recursive: true })
  await fs.writeFile(outPath, out, 'utf8')
  await fs.writeFile(outKindsPath, outKinds, 'utf8')

  console.log(`Wrote ${path.relative(projectRoot, outPath)} (${tableNames.length} tables)`)
  console.log(`Wrote ${path.relative(projectRoot, outKindsPath)} (${tableNames.length} tables)`)
}

main().catch((err) => {
  console.error(err)
  process.exit(1)
})
